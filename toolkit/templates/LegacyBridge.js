/**
 * ═══════════════════════════════════════════════════════════
 * ABSTRACT LEGACY BRIDGE CLASS - BASE TEMPLATE
 * ═══════════════════════════════════════════════════════════
 * 
 * GENERATED BY @necro-bridge/core
 * 
 * UNIVERSAL PATTERN FOR RESURRECTING ANCIENT COMPUTING SPIRITS
 * PROVIDES STANDARDIZED INTERFACE FOR SPAWNING AND COMMUNICATING
 * WITH COMPILED LEGACY BINARIES FROM MULTIPLE ERAS (1950s-1980s)
 * 
 * DESIGN PATTERN: BRIDGE PATTERN
 * - SEPARATES ABSTRACTION FROM IMPLEMENTATION
 * - ENABLES ADDING NEW LEGACY LANGUAGES WITHOUT MODIFYING CORE LOGIC
 * - TREATS VINTAGE CODE AS MICROSERVICES
 * 
 * USAGE:
 * 1. PLACE THIS FILE IN YOUR PROJECT ROOT OR BRIDGES DIRECTORY
 * 2. CREATE LANGUAGE-SPECIFIC BRIDGE CLASSES THAT EXTEND THIS CLASS
 * 3. IMPLEMENT THE parseOutput() METHOD IN EACH SUBCLASS
 */

const { exec } = require('child_process');
const path = require('path');

class LegacyBridge {
  /**
   * CONSTRUCT A NEW LEGACY BRIDGE INSTANCE
   * 
   * @param {Object} config - LANGUAGE CONFIGURATION
   * @param {string} config.name - LANGUAGE NAME (e.g., "COBOL")
   * @param {number} config.year - YEAR OF ORIGIN (e.g., 1959)
   * @param {string} config.binary - BINARY FILENAME (e.g., "mortgage")
   * @param {string} config.description - CALCULATION DESCRIPTION
   * @param {Array<string>} config.params - REQUIRED PARAMETER NAMES
   */
  constructor(config) {
    if (this.constructor === LegacyBridge) {
      throw new Error('CANNOT INSTANTIATE ABSTRACT CLASS LegacyBridge DIRECTLY');
    }
    
    this.config = config;
    this.name = config.name;
    this.year = config.year;
    this.binary = config.binary;
    this.description = config.description;
    this.params = config.params;
    this.timeout = config.timeout || 5000; // 5 SECOND DEFAULT TIMEOUT
  }
  
  /**
   * VALIDATE INPUT PARAMETERS AGAINST LANGUAGE REQUIREMENTS
   * 
   * @param {Object} params - INPUT PARAMETERS FROM REQUEST
   * @returns {Object} { valid: boolean, error: string|null }
   */
  validateParams(params) {
    // CHECK FOR MISSING PARAMETERS
    const missingParams = this.params.filter(param => params[param] === undefined);
    if (missingParams.length > 0) {
      return {
        valid: false,
        error: `MISSING PARAMETERS: ${missingParams.join(', ')}`
      };
    }
    
    // CHECK PARAMETER TYPES AND VALUES
    for (const param of this.params) {
      if (typeof params[param] !== 'number') {
        return {
          valid: false,
          error: `PARAMETER '${param}' MUST BE NUMERIC`
        };
      }
      
      if (params[param] <= 0) {
        return {
          valid: false,
          error: `PARAMETER '${param}' MUST BE POSITIVE`
        };
      }
    }
    
    return { valid: true, error: null };
  }
  
  /**
   * GET PATH TO LEGACY BINARY
   * SUBCLASSES CAN OVERRIDE TO CUSTOMIZE BINARY LOCATION
   * 
   * @returns {string} ABSOLUTE PATH TO BINARY
   */
  getBinaryPath() {
    // DEFAULT: ./legacy/<language>/<binary>
    const languageDir = this.name.toLowerCase();
    return path.join(process.cwd(), 'legacy', languageDir, this.binary);
  }
  
  /**
   * BUILD COMMAND STRING WITH PARAMETERS
   * SUBCLASSES CAN OVERRIDE TO CUSTOMIZE PARAMETER FORMATTING
   * 
   * @param {Object} params - INPUT PARAMETERS
   * @returns {string} COMMAND STRING TO EXECUTE
   */
  buildCommand(params) {
    const binaryPath = this.getBinaryPath();
    const paramValues = this.params.map(param => params[param]).join(' ');
    return `${binaryPath} ${paramValues}`;
  }
  
  /**
   * PARSE OUTPUT FROM LEGACY BINARY
   * ⚠️ SUBCLASSES MUST OVERRIDE THIS METHOD
   * 
   * @param {string} stdout - STANDARD OUTPUT FROM PROCESS
   * @returns {Object} { success: boolean, result: number|null, error: string|null }
   */
  parseOutput(stdout) {
    throw new Error('SUBCLASSES MUST IMPLEMENT parseOutput() METHOD');
  }
  
  /**
   * SPAWN LEGACY PROCESS AND EXECUTE CALCULATION
   * UNIVERSAL METHOD - HANDLES PROCESS SPAWNING, TIMEOUT, ERROR HANDLING
   * 
   * @param {Object} params - INPUT PARAMETERS
   * @returns {Promise<Object>} CALCULATION RESULT OR ERROR
   */
  async execute(params) {
    return new Promise((resolve, reject) => {
      // VALIDATE PARAMETERS
      const validation = this.validateParams(params);
      if (!validation.valid) {
        return reject({
          error: 'INVALID INPUT',
          details: validation.error,
          language: this.name
        });
      }
      
      // BUILD COMMAND
      const command = this.buildCommand(params);
      
      console.log(`[${this.name}] EXECUTING: ${command}`);
      
      // SPAWN LEGACY PROCESS WITH TIMEOUT
      exec(command, { timeout: this.timeout }, (error, stdout, stderr) => {
        // HANDLE EXECUTION ERRORS
        if (error) {
          console.error(`[${this.name}] EXECUTION FAILED:`, error.message);
          
          return reject({
            error: 'CORE DUMP DETECTED',
            details: error.message,
            stderr: stderr,
            language: this.name
          });
        }
        
        // PARSE OUTPUT USING SUBCLASS-SPECIFIC PARSER
        const parseResult = this.parseOutput(stdout);
        
        if (!parseResult.success) {
          console.error(`[${this.name}] PARSING FAILED:`, parseResult.error);
          
          return reject({
            error: 'PARSING FAILED',
            details: parseResult.error,
            raw_output: stdout,
            language: this.name
          });
        }
        
        // BUILD SUCCESSFUL RESPONSE
        const result = {
          result: parseResult.result,
          source: `${this.name}_LEGACY_ENGINE`,
          language: this.name.toLowerCase(),
          year: this.year,
          calculation: this.description,
          timestamp: new Date().toISOString()
        };
        
        console.log(`[${this.name}] SUCCESS:`, result.result);
        
        // RETURN SUCCESSFUL RESPONSE
        resolve(result);
      });
    });
  }
}

module.exports = LegacyBridge;
